{"ast":null,"code":"const sortData = (field, data, dir) => {\n  let sortedRecord = [...data];\n  if (dir && dir === \"desc\") {\n    sortedRecord = sortedRecord.sort((a, b) => {\n      if (typeof b[field] === \"number\") {\n        return b[field] - a[field];\n      } else {\n        return (b[field] || \"\").toLowerCase() > (a[field] || \"\").toLowerCase() ? 1 : -1;\n      }\n    });\n  } else {\n    sortedRecord = sortedRecord.sort((a, b) => {\n      if (typeof b[field] === \"number\") {\n        return a[field] - b[field];\n      } else {\n        return (a[field] || \"\").toLowerCase() > (b[field] || \"\").toLowerCase() ? 1 : -1;\n      }\n    });\n  }\n  return sortedRecord;\n};\nconst groupByFields = (array, f) => {\n  /*\n    params description :\n        f : function which returnf the array of fields \n        e.g. :  (item) => {\n            return [itemField1, itemField2];\n        }\n         array : array of data to group e.g. : [{...}, {...}]       \n    */\n\n  var groups = {};\n  array.forEach(o => {\n    var group = JSON.stringify(f(o));\n    groups[group] = groups[group] || [];\n    groups[group].push(o);\n  });\n  return Object.keys(groups).map(group => {\n    return groups[group];\n  });\n};\nconst divideByKey = (field, array) => {\n  let map = array.reduce((p, c) => {\n    let char = c[field].charAt(0).toUpperCase();\n    p[char] = [].concat(p[char] || [], c);\n    return p;\n  }, {});\n  let result = Object.keys(map).map(k => ({\n    letter: k,\n    data: map[k]\n  }));\n  result = sortData(\"letter\", result);\n  return result;\n};\nexport { sortData, groupByFields, divideByKey };","map":{"version":3,"names":["sortData","field","data","dir","sortedRecord","sort","a","b","toLowerCase","groupByFields","array","f","groups","forEach","o","group","JSON","stringify","push","Object","keys","map","divideByKey","reduce","p","c","char","charAt","toUpperCase","concat","result","k","letter"],"sources":["/home/olfa/Documents/pfe-main/client/src/utils/arrayutils.ts"],"sourcesContent":["const sortData = (field: string, data: Array<any>, dir?: string) => {\n  let sortedRecord = [...data];\n  if (dir && dir === \"desc\") {\n    sortedRecord = sortedRecord.sort((a: any, b: any) => {\n      if (typeof b[field] === \"number\") {\n        return b[field] - a[field];\n      } else {\n        return (b[field] || \"\").toLowerCase() > (a[field] || \"\").toLowerCase()\n          ? 1\n          : -1;\n      }\n    });\n  } else {\n    sortedRecord = sortedRecord.sort((a: any, b: any) => {\n      if (typeof b[field] === \"number\") {\n        return a[field] - b[field];\n      } else {\n        return (a[field] || \"\").toLowerCase() > (b[field] || \"\").toLowerCase()\n          ? 1\n          : -1;\n      }\n    });\n  }\n\n  return sortedRecord;\n};\n\nconst groupByFields = (array: any, f: any) => {\n  /*\n    params description :\n        f : function which returnf the array of fields \n        e.g. :  (item) => {\n            return [itemField1, itemField2];\n        }\n\n        array : array of data to group e.g. : [{...}, {...}]       \n    */\n\n  var groups: any = {};\n  array.forEach((o: any) => {\n    var group = JSON.stringify(f(o));\n    groups[group] = groups[group] || [];\n    groups[group].push(o);\n  });\n  return Object.keys(groups).map(group => {\n    return groups[group];\n  });\n};\nexport interface DivideByKeyResultTypes {\n  letter: string;\n  data: Array<any>;\n}\nconst divideByKey = (field: string, array: any) => {\n  let map = array.reduce((p: any, c: any) => {\n    let char = c[field].charAt(0).toUpperCase();\n    p[char] = [].concat(p[char] || [], c);\n    return p;\n  }, {});\n\n  let result = Object.keys(map).map(k => ({\n    letter: k,\n    data: map[k],\n  }));\n  result = sortData(\"letter\", result);\n  return result;\n};\nexport { sortData, groupByFields, divideByKey };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}